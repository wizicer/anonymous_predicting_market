<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Pedersen DKG Demo – Baby Jubjub (@zk-kit/baby-jubjub)</title>
    <script src="https://cdn.jsdelivr.net/npm/@zk-kit/baby-jubjub"></script>
    <style>
      body {
        font-family: system-ui, sans-serif;
        margin: 2em;
      }
      pre {
        background: #f6f6f6;
        padding: 1em;
        border-radius: 8px;
        white-space: pre-wrap;
      }
      button {
        margin: 0.3em;
      }
      h3 {
        margin-top: 1.4em;
      }
    </style>
  </head>
  <body>
    <h2>Pedersen DKG Demo (Baby Jubjub)</h2>
    <p>
      This demo simulates 3 participants (t=2) executing a two-round Pedersen
      DKG protocol. It shows commitments, shares, and reconstruction logic in
      detail.
    </p>
    <button id="run">Run DKG</button>
    <pre id="out"></pre>

    <script>
      BigInt.prototype.toJSON = function () {
        return this.toString();
      };

      const out = document.getElementById("out");
      const log = (...a) => (out.textContent += a.join(" ") + "\n");

      const { Base8, addPoint, mulPointEscalar } = window.babyJubjub;

      // Baby Jubjub subgroup order r
      const r = BigInt(
        "2736030358979909402780800718157159386076813972158567259200215660948447373041"
      );

      // utility
      function mod(a, m = r) {
        return ((a % m) + m) % m;
      }
      function randScalar() {
        const arr = crypto.getRandomValues(new Uint8Array(32));
        let x = 0n;
        for (let i = 0; i < 32; i++) x = (x << 8n) + BigInt(arr[i]);
        return mod(x);
      }
      function evalPoly(coeffs, x) {
        let res = 0n,
          pow = 1n;
        for (const c of coeffs) {
          res = mod(res + c * pow);
          pow = mod(pow * BigInt(x));
        }
        return res;
      }
      function mul(s) {
        return mulPointEscalar(Base8, s);
      }
      function verifyShare(share, commitments, index) {
        let rhs = [0n, 1n],
          pow = 1n;
        for (const C of commitments) {
          const Ci = mulPointEscalar(C, pow);
          rhs = addPoint(rhs, Ci);
          pow = mod(pow * BigInt(index));
        }
        const lhs = mulPointEscalar(Base8, share);
        return lhs[0] === rhs[0] && lhs[1] === rhs[1];
      }
      function modInv(a, m = r) {
        let lm = 1n,
          hm = 0n;
        let low = mod(a, m),
          high = m;
        while (low > 1n) {
          const ratio = high / low;
          [lm, hm] = [hm - lm * ratio, lm];
          [low, high] = [high - low * ratio, low];
        }
        return mod(lm, m);
      }

      document.getElementById("run").onclick = () => {
        out.textContent = "";
        const n = 3,
          t = 2;
        log(`=== Distributed Key Generation (n=${n}, threshold t=${t}) ===\n`);

        // --- Round 1: Commit phase ---
        log(
          ">> Round 1: Each participant chooses random polynomial f_i(x) = a0 + a1*x, commits to coefficients."
        );
        const polys = [],
          commits = [];
        for (let i = 0; i < n; i++) {
          const coeffs = Array.from({ length: t }, () => randScalar());
          polys.push(coeffs);
          commits.push(coeffs.map((c) => mul(c)));
          log(`P${i + 1}: f_${i + 1}(x) = ${coeffs[0]} + ${coeffs[1]}*x`);
          log(`   Commitment C_${i + 1} = [ g^{a0}, g^{a1} ] =`);
          log(`     [${commits[i][0][0]}, ${commits[i][0][1]}]`);
          log(`     [${commits[i][1][0]}, ${commits[i][1][1]}]\n`);
        }

        // --- Round 2: Share phase ---
        log(
          "\n>> Round 2: Each participant evaluates f_i(j) for every j, sends s_ij privately."
        );
        const shares = Array.from({ length: n }, () => Array(n).fill(0n));
        for (let i = 0; i < n; i++) {
          for (let j = 0; j < n; j++) {
            shares[i][j] = evalPoly(polys[i], j + 1);
            log(
              `P${i + 1} → P${j + 1}: sends s_${i + 1}${j + 1} = f_${i + 1}(${
                j + 1
              }) = ${shares[i][j]}`
            );
          }
        }

        // --- Each participant computes final share ---
        log("\n>> Each participant sums received shares: s_j = Σ_i s_ij");
        const finalShares = [];
        for (let j = 0; j < n; j++) {
          let sum = 0n;
          const details = [];
          for (let i = 0; i < n; i++) {
            sum = mod(sum + shares[i][j]);
            details.push(`s_${i + 1}${j + 1}`);
          }
          finalShares.push(sum);
          log(`P${j + 1}: s_${j + 1} = ${details.join(" + ")} = ${sum}`);
        }

        // --- Verification of shares ---
        log("\n>> Verifying each received share using commitments:");
        for (let j = 0; j < n; j++) {
          let ok = true;
          for (let i = 0; i < n; i++) {
            if (!verifyShare(shares[i][j], commits[i], j + 1)) {
              ok = false;
              break;
            }
          }
          log(`P${j + 1} verification result: ${ok}`);
        }

        // --- Compute group public key ---
        log("\n>> Computing group public key:");
        log(
          "Each participant’s commitment to a0 (C_i0) corresponds to g^{a_i0}."
        );
        log("The group public key is pk = Σ_i g^{a_i0}.");
        let pk = [0n, 1n];
        for (let i = 0; i < n; i++) pk = addPoint(pk, commits[i][0]);
        log(`pk = [${pk[0]}, ${pk[1]}]\n`);

        // --- Reconstruct secret from any t shares (e.g., 1 & 2) ---
        log(
          ">> Reconstructing secret from shares 1 and 2 using Lagrange interpolation:"
        );
        const lambda = (i, S) => {
          let num = 1n,
            den = 1n;
          for (const j of S)
            if (j !== i) {
              num = mod(num * BigInt(-j));
              den = mod(den * BigInt(i - j));
            }
          return mod(num * modInv(den));
        };
        const subset = [1, 2];
        let secret = 0n;
        for (const i of subset)
          secret = mod(secret + finalShares[i - 1] * lambda(i, subset));
        log(
          `f(0) = ${subset.map((i) => `λ_${i}*s_${i}`).join(" + ")} = ${secret}`
        );

        const pk2 = mul(secret);
        const match = pk2[0] === pk[0] && pk2[1] === pk[1];
        log(`pk' = g^{f(0)} = [${pk2[0]}, ${pk2[1]}]`);
        log(`pk' == pk ? ${match}\n`);

        // --- Summary of what is public/private ---
        log("=== Visibility Summary ===");
        log("• Public: all commitments C_i (posted on chain)");
        log(
          "• Private: individual coefficients a_ij, shares s_ij, final shares s_j, secret f(0)"
        );
        log(
          "• Public key pk = Σ_i g^{a_i0}, used for EdDSA or verification on-chain."
        );
      };
    </script>
  </body>
</html>
